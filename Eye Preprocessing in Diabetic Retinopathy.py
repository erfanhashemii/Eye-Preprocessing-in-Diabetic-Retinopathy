# -*- coding: utf-8 -*-
"""Untitled55.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1miliUFqc7j4tJCqTUnq4MI-zNPBqStC6
"""

df_train = pd.read_csv('../input/aptos2019-blindness-detection/train.csv')
df_test = pd.read_csv('../input/aptos2019-blindness-detection/test.csv')

x = df_train['id_code']
y = df_train['diagnosis']

x, y = shuffle(x, y, random_state=SEED)

train_x, valid_x, train_y, valid_y = train_test_split(x, y, test_size=0.15,
                                                      stratify=y, random_state=SEED)
print(train_x.shape, train_y.shape, valid_x.shape, valid_y.shape)
train_y.hist()
valid_y.hist()

# Commented out IPython magic to ensure Python compatibility.
# %%time
# fig = plt.figure(figsize=(25, 16))
# for class_id in sorted(train_y.unique()):
#     for i, (idx, row) in enumerate(df_train.loc[df_train['diagnosis'] == class_id].sample(5, random_state=SEED).iterrows()):
#         ax = fig.add_subplot(5, 5, class_id * 5 + i + 1, xticks=[], yticks=[])
#         path=f"../input/aptos2019-blindness-detection/train_images/{row['id_code']}.png"
#         image = cv2.imread(path)
#         image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
# #         image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
#         image = cv2.resize(image, (IMG_SIZE, IMG_SIZE))
#         image=cv2.addWeighted ( image,4, cv2.GaussianBlur( image , (0,0) , IMG_SIZE/10) ,-4 ,128) # the trick is to add this line
# 
#         plt.imshow(image, cmap='gray')
#         ax.set_title('Label: %d-%d-%s' % (class_id, idx, row['id_code']) )

def crop_image1(img,tol=7):
    # img is image data
    # tol  is tolerance

    mask = img>tol
    return img[np.ix_(mask.any(1),mask.any(0))]
def crop_image_from_gray(img,tol=7):
    if img.ndim ==2:
        mask = img>tol
        return img[np.ix_(mask.any(1),mask.any(0))]
    elif img.ndim==3:
        gray_img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
        mask = gray_img>tol

        check_shape = img[:,:,0][np.ix_(mask.any(1),mask.any(0))].shape[0]
        if (check_shape == 0): # image is too dark so that we crop out everything,
            return img # return original image
        else:
            img1=img[:,:,0][np.ix_(mask.any(1),mask.any(0))]
            img2=img[:,:,1][np.ix_(mask.any(1),mask.any(0))]
            img3=img[:,:,2][np.ix_(mask.any(1),mask.any(0))]
    #         print(img1.shape,img2.shape,img3.shape)
            img = np.stack([img1,img2,img3],axis=-1)
    #         print(img.shape)
        return img

def load_ben_color(path, sigmaX=10):
    image = cv2.imread(path)
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    image = crop_image_from_gray(image)
    image = cv2.resize(image, (IMG_SIZE, IMG_SIZE))
    image=cv2.addWeighted ( image,4, cv2.GaussianBlur( image , (0,0) , sigmaX) ,-4 ,128)

    return image

# Commented out IPython magic to ensure Python compatibility.
# %%time
# ## try circle crop
# NUM_SAMP=7
# fig = plt.figure(figsize=(25, 16))
# for class_id in sorted(train_y.unique()):
#     for i, (idx, row) in enumerate(df_train.loc[df_train['diagnosis'] == class_id].sample(NUM_SAMP, random_state=SEED).iterrows()):
#         ax = fig.add_subplot(5, NUM_SAMP, class_id * NUM_SAMP + i + 1, xticks=[], yticks=[])
#         path=f"../input/aptos2019-blindness-detection/train_images/{row['id_code']}.png"
#         image = circle_crop(path,sigmaX=30)
# 
#         plt.imshow(image)
#         ax.set_title('%d-%d-%s' % (class_id, idx, row['id_code']) )

!ls ../input/diabetic-retinopathy-resized/

!ls ../input/diabetic-retinopathy-resized/resized_train/resized_train | head

df_old = pd.read_csv('../input/diabetic-retinopathy-resized/trainLabels.csv')

df_old.head()